{
  "version": "1.0",
  "skill": "skills/scope",
  "cases": [
    {
      "id": "happy-path-spec-then-plan",
      "prompt": "You are Claude following the scope skill instructions. The user invokes '/scope add webhook retry with exponential backoff'. The project root is /fake/project. CLAUDE_CODE_TASK_LIST_ID is set.\n\nDemonstrate the full flow: create tracking task, dispatch research subagent, validate findings, synthesize spec, present spec, get user approval of spec, then generate plan, present plan, and stop for plan review.\n\nResearch subagent returns findings in fixtures/research-findings.md.",
      "files": [
        "fixtures/research-findings.md"
      ],
      "expectations": [
        {
          "criterion": "spec-presented-first",
          "description": "After research and validation, a spec is synthesized and presented FIRST. The spec covers WHAT we're building: problem statement, recommendation (target-state, present tense), architecture context (conceptual code landscape — NOT files to create/modify), risks. It does NOT include implementation phases, file change lists, or code-level changes like 'add X to Y' — those belong to the plan.",
          "required": true
        },
        {
          "criterion": "spec-is-timeless-target-state",
          "description": "The spec's Recommendation describes the target system in present tense, as if already implemented ('Webhook delivery uses exponential backoff via BullMQ'). Avoids transition verbs (add, replace, migrate, move, change). After implementation, the spec reads as a valid specification of the system, not a dated change request.",
          "required": true
        },
        {
          "criterion": "spec-stops-for-approval",
          "description": "After presenting the spec, execution stops and waits for user approval. The plan (phased implementation approach) is NOT generated or presented until the spec is explicitly approved.",
          "required": true
        },
        {
          "criterion": "plan-generated-after-spec-approval",
          "description": "Only after user approves the spec does scope generate the implementation plan (phased approach with file paths, steps, approaches). The plan is a separate artifact stored in metadata.design, distinct from the spec in metadata.spec.",
          "required": true
        },
        {
          "criterion": "plan-stops-for-review",
          "description": "After presenting the plan, execution stops and waits for user review before proceeding to develop. Includes 'Next: /develop t<id>'.",
          "required": true
        },
        {
          "criterion": "does-not-create-epic-or-tasks",
          "description": "Scope ONLY produces spec + plan. It does NOT create an epic or tasks. Epic and task creation are develop's job.",
          "required": true
        }
      ]
    },
    {
      "id": "spec-refinement-persists",
      "prompt": "You are Claude following the scope skill instructions. You completed research for '/scope add webhook retry'. Tracking task #100 with metadata.spec populated and status_detail='spec_review'. Spec has been presented to the user.\n\nUser says: 'I think we should use a dead letter queue instead of just retry. Also add idempotency keys.'\n\nDemonstrate spec refinement.",
      "files": [],
      "expectations": [
        {
          "criterion": "revises-spec-not-plan",
          "description": "Revises the spec (what we're building) based on feedback. Does NOT generate or modify a plan — the plan doesn't exist yet because the spec hasn't been approved.",
          "required": true
        },
        {
          "criterion": "persists-before-re-presenting",
          "description": "TaskUpdate with revised metadata.spec happens BEFORE re-presenting the spec to the user. Downstream skills read stored artifacts, not conversation context.",
          "required": true
        },
        {
          "criterion": "stays-in-spec-review",
          "description": "status_detail remains 'spec_review' after refinement. Does NOT advance to plan generation or 'review' status.",
          "required": true
        }
      ]
    },
    {
      "id": "auto-approve-both-phases",
      "prompt": "You are Claude following the scope skill instructions. The user invokes '/scope add webhook retry --auto-approve'. CLAUDE_CODE_TASK_LIST_ID is set.\n\nYou complete research and validation. Now demonstrate the full flow through spec and plan with --auto-approve.\n\nResearch subagent returns findings in fixtures/research-findings.md.",
      "files": [
        "fixtures/research-findings.md"
      ],
      "expectations": [
        {
          "criterion": "spec-auto-approved",
          "description": "With --auto-approve, the spec is produced and stored but user review is skipped — does NOT stop for user feedback on the spec.",
          "required": true
        },
        {
          "criterion": "plan-auto-approved",
          "description": "The plan is also auto-approved — does NOT stop for user feedback on the plan either. Both phases skip review.",
          "required": true
        },
        {
          "criterion": "both-artifacts-stored",
          "description": "Both metadata.spec and metadata.design are populated. Both archival procedures run (ct spec create for spec, ct plan create for plan). Both file paths stored in metadata (spec_file, plan_file).",
          "required": true
        },
        {
          "criterion": "invokes-develop-with-task-id",
          "description": "After both phases complete, sets status_detail='approved' and invokes Skill('develop', 't<scopeTaskId>') with the explicit task ID.",
          "required": true
        }
      ]
    },
    {
      "id": "plan-refinement-after-spec",
      "prompt": "You are Claude following the scope skill instructions. Spec for '/scope add webhook retry' was approved. Tracking task #100 with metadata.spec populated, metadata.design populated, metadata.plan_file set. status_detail is 'review'.\n\nUser says: 'Use an outbox pattern instead of direct retry for the first phase.'\n\nDemonstrate plan refinement.",
      "files": [],
      "expectations": [
        {
          "criterion": "approach-feedback-stays-in-plan",
          "description": "This feedback ('use an outbox pattern instead of direct retry') changes the HOW (approach for phase 1), not the WHAT. So metadata.spec is unchanged and only metadata.design is revised. If feedback had changed what we're building, both spec and plan would be updated.",
          "required": true
        },
        {
          "criterion": "updates-design-before-re-presenting",
          "description": "TaskUpdate with revised metadata.design happens BEFORE re-presenting the plan. Overwrites plan_file if it exists (does NOT create a new file).",
          "required": true
        },
        {
          "criterion": "approval-sets-status-and-invokes-develop",
          "description": "After user approves plan: TaskUpdate status_detail='approved', then Skill('develop', 't100'). Task ID is passed explicitly.",
          "required": true
        }
      ]
    },
    {
      "id": "spec-plan-archival",
      "prompt": "You are Claude following the scope skill instructions. You have completed research for '/scope add webhook retry'. Demonstrate the archival procedure for BOTH the spec (after spec approval) and the plan (after plan generation).\n\nShow the exact commands/calls used to archive each artifact.",
      "files": [],
      "expectations": [
        {
          "criterion": "spec-uses-ct-spec-create",
          "description": "Spec is archived using 'ct spec create' with --prefix 'scope' — mirroring the plan archival mechanism. git notes is NOT used for the spec. Spec file path stored in metadata.spec_file.",
          "required": true
        },
        {
          "criterion": "plan-uses-ct-plan-create",
          "description": "Plan is archived using 'ct plan create' with --prefix 'scope' — the existing archival mechanism. git notes is NOT used for the plan. Plan file path stored in metadata.plan_file.",
          "required": true
        },
        {
          "criterion": "both-stored-in-metadata",
          "description": "Spec stored in metadata.spec AND plan stored in metadata.design. Both fields are populated as separate metadata entries.",
          "required": true
        }
      ]
    },
    {
      "id": "spec-to-repo-option",
      "prompt": "You are Claude following the scope skill instructions. Both spec and plan are approved for '/scope add webhook retry'. Tracking task #100. User is about to proceed to develop.\n\nDemonstrate the spec-to-repo option that should be offered at the end.",
      "files": [],
      "expectations": [
        {
          "criterion": "offers-spec-file-option",
          "description": "After plan approval, AskUserQuestion offers the option to save the spec as a file in the repository. This is optional — user can decline.",
          "required": true
        },
        {
          "criterion": "writes-file-if-accepted",
          "description": "If user accepts, writes the spec content as a markdown file in the repo. The file will be included in the eventual commit alongside implementation files.",
          "required": true
        },
        {
          "criterion": "proceeds-regardless",
          "description": "Whether user accepts or declines the spec file option, scope proceeds to invoke develop (or stop if --no-develop).",
          "required": true
        }
      ]
    },
    {
      "id": "continue-spec-review",
      "prompt": "You are Claude following the scope skill instructions. The user invokes '/scope --continue'. CLAUDE_CODE_TASK_LIST_ID is set.\n\nTaskList() finds task 500: metadata.type='scope', status='in_progress', status_detail='spec_review', metadata.spec populated.\n\nDemonstrate the --continue workflow for a task in spec review.",
      "files": [],
      "expectations": [
        {
          "criterion": "resumes-spec-not-plan",
          "description": "Detects status_detail='spec_review' and re-presents the spec for user review. Does NOT skip to plan generation or invoke develop.",
          "required": true
        },
        {
          "criterion": "handles-feedback-or-approval",
          "description": "If user provides feedback, enters spec refinement loop. If user approves, proceeds to plan generation.",
          "required": true
        }
      ]
    },
    {
      "id": "continue-plan-review",
      "prompt": "You are Claude following the scope skill instructions. The user invokes '/scope --continue add more detail about error handling'. CLAUDE_CODE_TASK_LIST_ID is set.\n\nTaskList() finds task 500: metadata.type='scope', status='in_progress', status_detail='review', metadata.spec populated, metadata.design populated, metadata.plan_file='/tmp/scope-webhook.md'.\n\nDemonstrate the --continue workflow for a task in plan review.",
      "files": [],
      "expectations": [
        {
          "criterion": "dispatches-with-prior-findings",
          "description": "Dispatches a research subagent with both the prior metadata.design AND the new prompt. The subagent merges, not replaces.",
          "required": true
        },
        {
          "criterion": "overwrites-plan-file-not-creates-new",
          "description": "Updates metadata.design AND overwrites the existing plan file (metadata.plan_file). Does NOT create a new plan file.",
          "required": true
        },
        {
          "criterion": "re-enters-plan-presentation",
          "description": "After merging, re-enters the plan presentation flow. Does NOT re-present the spec (already approved). Does not skip to approval.",
          "required": true
        }
      ]
    },
    {
      "id": "continue-approved-invokes-develop",
      "prompt": "You are Claude following the scope skill instructions. The user invokes '/scope --continue'. CLAUDE_CODE_TASK_LIST_ID is set.\n\nTaskList() finds task 500: metadata.type='scope', status='in_progress', status_detail='approved', metadata.spec populated, metadata.design populated.\n\nDemonstrate the --continue workflow.",
      "files": [],
      "expectations": [
        {
          "criterion": "detects-approved-skips-to-develop",
          "description": "Recognizes status_detail='approved' and immediately invokes Skill('develop', 't500'). Does NOT re-research, re-present spec or plan, or re-enter any review loop.",
          "required": true
        }
      ]
    },
    {
      "id": "major-feedback-dispatches-subagent",
      "prompt": "You are Claude following the scope skill instructions. Spec approved, plan presented for '/scope add webhook retry'. Tracking task #100, status_detail='review'.\n\nUser says: 'Actually, I think we need to use an event-driven architecture with message queues instead. Can you research how our codebase handles async messaging?'\n\nDemonstrate plan refinement with major feedback.",
      "files": [],
      "expectations": [
        {
          "criterion": "dispatches-subagent-for-new-research",
          "description": "Recognizes this needs new codebase data and dispatches a follow-up research subagent. Does NOT attempt to revise from stored findings alone — the user explicitly asked to research something new.",
          "required": true
        },
        {
          "criterion": "merges-and-persists",
          "description": "Merges new research with existing plan, then persists to metadata.design AND overwrites plan file if exists. metadata.spec is NOT modified — the spec (what) was already approved.",
          "required": true
        }
      ]
    },
    {
      "id": "spec-abstraction-boundary",
      "prompt": "You are Claude following the scope skill instructions. Research subagent returns findings for '/scope add persistence to sync queue':\n\n## Current State\n- SyncChangeQueue.swift: in-memory queue, fire-and-forget\n- SyncChangeTracker.swift: adapter-level state, coordinates queue ops\n- SyncPersistenceClient.swift: only persists marker/birthday (4 closures)\n- SyncEntity.swift: Equatable+Sendable but NOT Codable\n- MemoryDatabase.swift: existing GRDB patterns in Memory module\n\n## Key Files\n- SyncChangeQueue.swift: modify — add persistence backing\n- SyncChangeTracker.swift: modify — wire persistence for metadata\n- SyncEntity.swift: modify — add Codable conformance\n- Sync/Persistence/SyncDatabase.swift: create — GRDB setup + migrations\n- Sync/Persistence/SyncQueueRecord.swift: create — GRDB record type\n- Sync/Persistence/SyncQueueStore.swift: create — load/save API\n\n## Recommended Approach\nDedicated GRDB database for sync state. GRDB transactions for atomic persist-and-clear.\n\n## Suggested Phases\nPhase 1: Database + record types. Phase 2: Wire into queue + tracker. Phase 3: Integration tests.\n\nSynthesize the spec from these findings. Show the spec content.\n\nCRITICAL: The research findings contain implementation-level details (files to create/modify, specific code changes). The spec must abstract UP from these.",
      "files": [],
      "expectations": [
        {
          "criterion": "architecture-context-is-conceptual",
          "description": "The spec's Architecture Context section describes the existing code landscape conceptually — by module role and pattern, not by hardcoded file path. E.g., 'the sync queue module (in-memory, fire-and-forget)', 'the persistence client (currently limited to marker/birthday)', 'existing GRDB patterns in the Memory module'. File paths may appear parenthetically but the description stands without them. Does NOT list files to create or describe modifications.",
          "required": true
        },
        {
          "criterion": "recommendation-is-strategy-not-code",
          "description": "The recommendation describes the chosen approach at a strategy level ('dedicated GRDB database for sync state persistence') without specifying code changes, file modifications, or implementation steps. Rationale explains WHY this approach, not WHAT code to write.",
          "required": true
        },
        {
          "criterion": "spec-is-timeless-target-state",
          "description": "The Recommendation describes the target system in present tense ('sync state persists in a dedicated GRDB database with atomic transactions'), not as a transition ('add persistence to the sync queue'). The Problem section may describe current state, but the Recommendation reads as a specification of the target system — valid as a reference document after implementation.",
          "required": true
        },
        {
          "criterion": "no-files-to-create-or-modify",
          "description": "The spec does NOT contain Create/Modify annotations, file change tables, or phrases like 'add X to Y.swift', 'create Z.swift', 'extend W with'. These belong exclusively in the plan.",
          "required": true
        }
      ]
    },
    {
      "id": "no-task-tools-guard",
      "prompt": "You are Claude following the scope skill instructions. The user invokes '/scope add webhook retry'. CLAUDE_CODE_TASK_LIST_ID is NOT set.\n\nDemonstrate what happens.",
      "files": [],
      "expectations": [
        {
          "criterion": "detects-early-and-stops",
          "description": "The shell guard at the top detects CLAUDE_CODE_TASK_LIST_ID is unset and outputs a warning BEFORE any research is dispatched. Tells the user to set it in .claude/settings.json.",
          "required": true
        }
      ]
    },
    {
      "id": "validation-stays-lightweight",
      "prompt": "You are Claude following the scope skill instructions. The research subagent returns findings referencing 8 files with claims like 'SyncEngine.swift exports the main sync loop' and 'HTTPSyncProtocolClient.swift handles retry logic'.\n\nDemonstrate step 3 (Validate research).",
      "files": [],
      "expectations": [
        {
          "criterion": "spot-checks-not-full-reads",
          "description": "Uses Grep or short Read (a few lines) to confirm claims. Does NOT read entire files — validation is spot-checking, not research.",
          "required": true
        },
        {
          "criterion": "checks-odd-numbered-minimum-3",
          "description": "Checks every odd-numbered claim (1st, 3rd, 5th...) with minimum 3 checks. ALL architectural claims are checked.",
          "required": true
        }
      ]
    },
    {
      "id": "spec-timelessness",
      "prompt": "You are Claude following the scope skill instructions. Research subagent returns findings for '/scope add webhook retry with exponential backoff':\n\n## Current State\n- src/webhooks/sender.ts: fire-and-forget HTTP POST, no retry logic\n- src/webhooks/types.ts: WebhookPayload interface, DeliveryStatus enum\n- src/lib/queue.ts: BullMQ queue wrapper, supports delayed jobs and retries\n\n## Analysis\nThe codebase already has BullMQ infrastructure. Adding retry to webhooks should leverage the existing queue wrapper.\n\nKey decisions:\n- Exponential backoff: base 1s, factor 2x, max 5 attempts, jitter +/-20%\n- Dead letter queue for permanently failed deliveries\n- Idempotency keys to prevent duplicate delivery\n\n## Recommended Approach\nUse BullMQ delayed jobs for retry with exponential backoff.\n\nSynthesize the spec from these findings. Show ONLY the spec content.\n\nCRITICAL: The research findings use change language ('adding retry', 'should leverage'). The spec must describe the TARGET SYSTEM, not the transition.",
      "files": [],
      "expectations": [
        {
          "criterion": "recommendation-uses-present-tense",
          "description": "The Recommendation section describes the target system in present tense, as if already implemented. Uses phrases like 'Webhook delivery uses exponential backoff' or 'Failed deliveries move to a dead letter queue' — NOT 'Add retry', 'Replace fire-and-forget with queue-based delivery', 'Change sender to use BullMQ'.",
          "required": true
        },
        {
          "criterion": "no-transition-verbs-in-recommendation",
          "description": "The Recommendation avoids transition verbs: add, replace, migrate, move, change, convert, switch, introduce, implement, create. These describe what to DO, not what the system IS. The Problem section MAY reference current state, but Recommendation must be target-state only.",
          "required": true
        },
        {
          "criterion": "readable-post-implementation",
          "description": "The spec as a whole would still make sense and be accurate as a reference document AFTER implementation. Someone reading it after the work is done would understand what the system does, not what was changed. It's a timeless specification, not a time-bound change request.",
          "required": true
        }
      ]
    }
  ]
}
